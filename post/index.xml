<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on SmithFox Blog</title>
    <link>http://smithfox.github.io/post/</link>
    <description>Recent content in Posts on SmithFox Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <copyright>@ 2015 by SmithFox</copyright>
    <lastBuildDate>Tue, 26 May 2015 16:32:07 +0800</lastBuildDate>
    <atom:link href="http://smithfox.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>用golan进行词法分析，第一部分</title>
      <link>http://smithfox.github.io/post/p3/</link>
      <pubDate>Tue, 26 May 2015 16:32:07 +0800</pubDate>
      
      <guid>http://smithfox.github.io/post/p3/</guid>
      <description>

&lt;h3 id=&#34;主要步骤:3338874448cf36f2056dd96b34bbe8b9&#34;&gt;主要步骤&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;词法分析(lexical parse或是lexical scan) 得到 token&lt;/li&gt;
&lt;li&gt;语法分析(syntax parse)得到AST(syntax tree)&lt;/li&gt;
&lt;li&gt;语义分析(semantic parse)修改AST&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;词法分析常见问题:3338874448cf36f2056dd96b34bbe8b9&#34;&gt;词法分析常见问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;输入内容编码问题: 可能有汉字
&amp;gt; 词法分析前，都转换为utf-8，要注意utf-8的BOM问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;源文件不止一个，如何组织
&amp;gt; 一般是抽象File和FileSet，但这个File和io.File不一样&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;怎么让处理错误? 推出逻辑和显示
&amp;gt; 需要知道是哪个文件，哪行哪列&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;转义问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数的词法，其他进制(8进制和16进制)，科学数字表示&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Token如何定义&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;先来一个简化的词法分析:3338874448cf36f2056dd96b34bbe8b9&#34;&gt;先来一个简化的词法分析&lt;/h3&gt;

&lt;p&gt;没有源代码文件，直接string源代码。utf-8编码，不处理转义，直接printf错误，只有10进制。
&lt;strong&gt;我们要分析&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int ak = 38;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们的原则是麻雀虽小五脏俱全&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
)

const (
	_         int = iota //
	ILLEGAL              //
	EOF                  //
	IDENT                // main
	DECLINT              // int
	NUMBER               // 123
	ASSIGN               // =
	SEMICOLON            // ;
)

var TOKEN_NAMES = [...]string{
	ILLEGAL:   &amp;quot;ILLEGAL&amp;quot;,
	EOF:       &amp;quot;EOF&amp;quot;,
	IDENT:     &amp;quot;IDENT&amp;quot;,
	DECLINT:   &amp;quot;DECLINT&amp;quot;,
	NUMBER:    &amp;quot;NUMBER&amp;quot;,
	ASSIGN:    &amp;quot;ASSIGN&amp;quot;,
	SEMICOLON: &amp;quot;SEMICOLON&amp;quot;,
}

type Token struct {
	TokenType   int
	TokenName   string
	TokenString string
}

func IsKeywordToken(ss string) (int, bool) {
	if ss == &amp;quot;int&amp;quot; {
		return DECLINT, true
	}
	return IDENT, false
}

type Source struct {
	str string
	d0  int
	d1  int
	c   rune
	l   int
}

func (m *Source) next() {
	if m.d1 &amp;lt; m.l {
		m.d0 = m.d1
		m.c = rune(m.str[m.d0])
		m.d1++
	} else {
		m.d0 = m.l
		m.c = -1 // EOF
	}
}

func IsWhiteSpace(chr rune) bool {
	if chr == &#39; &#39; || chr == &#39;\t&#39; || chr == &#39;\n&#39; || chr == &#39;\r&#39; {
		return true
	} else {
		return false
	}
}

func (m *Source) skipWhiteSpace() {
	for IsWhiteSpace(m.c) {
		m.next()
	}
}

func IsNumber(chr rune) bool {
	if &#39;0&#39; &amp;lt;= chr &amp;amp;&amp;amp; chr &amp;lt;= &#39;9&#39; {
		return true
	}
	return false
}

func (m *Source) skipNumber() {
	for IsNumber(m.c) {
		m.next()
	}
}

func IsLetter(chr rune) bool {
	if &#39;a&#39; &amp;lt;= chr &amp;amp;&amp;amp; chr &amp;lt;= &#39;z&#39; || &#39;A&#39; &amp;lt;= chr &amp;amp;&amp;amp; chr &amp;lt;= &#39;Z&#39; {
		return true
	}
	return false
}

func (m *Source) skipLetters() {
	for IsLetter(m.c) {
		m.next()
	}
}

func (m *Source) printf() {
	fmt.Printf(&amp;quot;(d0:%d, d1:%d)\n&amp;quot;, m.d0, m.d1)
}

func main() {
	src := `int ak = 38;`
	source := &amp;amp;Source{str: src, l: len(src), c: rune(src[0])}
	tokens, err := scan(source)
	if err != nil {
		fmt.Printf(&amp;quot;scan err=%v\n&amp;quot;, err)
		return
	}
	show(tokens)
}

func scan(source *Source) ([]*Token, error) {
	tokens := []*Token{}
	n := 0
	for {
		n++
		if n &amp;gt; 100 {
			break
		}
		source.printf()
		source.skipWhiteSpace()
		switch c := source.c; {
		case IsLetter(c):
			d0 := source.d0
			source.skipLetters()
			ss := source.str[d0 : source.d1-1]
			//fmt.Printf(&amp;quot;ss=%s,source.d1=%d,source.d0=%d,d0=%d\n&amp;quot;, ss, source.d1, source.d0, d0)
			tmptoken, iskeyword := IsKeywordToken(ss)
			if iskeyword {
				tokens = append(tokens, &amp;amp;Token{TokenType: tmptoken, TokenName: TOKEN_NAMES[tmptoken], TokenString: ss})
			} else {
				tokens = append(tokens, &amp;amp;Token{TokenType: IDENT, TokenName: TOKEN_NAMES[IDENT], TokenString: ss})
			}
		case IsNumber(c):
			d0 := source.d0
			source.skipNumber()
			ss := source.str[d0 : source.d1-1]
			tokens = append(tokens, &amp;amp;Token{TokenType: NUMBER, TokenName: TOKEN_NAMES[NUMBER], TokenString: ss})
		case c == &#39;;&#39;:
			tokens = append(tokens, &amp;amp;Token{TokenType: SEMICOLON, TokenName: TOKEN_NAMES[SEMICOLON], TokenString: &amp;quot;;&amp;quot;})
			source.next()
		case c == &#39;=&#39;:
			tokens = append(tokens, &amp;amp;Token{TokenType: ASSIGN, TokenName: TOKEN_NAMES[ASSIGN], TokenString: &amp;quot;=&amp;quot;})
			source.next()
		case c == -1:
			tokens = append(tokens, &amp;amp;Token{TokenType: EOF, TokenName: TOKEN_NAMES[EOF], TokenString: &amp;quot;&amp;quot;})
			goto _exit
		default:
			tokens = append(tokens, &amp;amp;Token{TokenType: ILLEGAL, TokenName: TOKEN_NAMES[ILLEGAL], TokenString: &amp;quot;&amp;quot;})
			goto _exit
		}
	}
_exit:
	return tokens, nil
}

func show(tokens []*Token) {
	for _, token := range tokens {
		fmt.Printf(&amp;quot;[&amp;quot; + token.TokenName + &amp;quot;],&amp;quot;)
	}
	fmt.Printf(&amp;quot;\n--------------------------\n&amp;quot;)
	for _, token := range tokens {
		fmt.Printf(&amp;quot;[&amp;quot; + token.TokenString + &amp;quot;],&amp;quot;)
	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://wide.b3log.org/playground/ce2e3f4ea0984c953aebd8223367bb7b.go&#34;&gt;play&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>网站的基本样式</title>
      <link>http://smithfox.github.io/post/second/</link>
      <pubDate>Mon, 25 May 2015 20:16:44 +0800</pubDate>
      
      <guid>http://smithfox.github.io/post/second/</guid>
      <description>

&lt;h1 id=&#34;网站的基本样式参考:9f7936f9b5c071ae81db818b80a44a0d&#34;&gt;网站的基本样式参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://purecss.io/&#34;&gt;purecss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://topcoat.io/&#34;&gt;topcoat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://necolas.github.io/normalize.css/&#34;&gt;normalize.css&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Markdown示例</title>
      <link>http://smithfox.github.io/post/first/</link>
      <pubDate>Mon, 25 May 2015 14:21:17 +0800</pubDate>
      
      <guid>http://smithfox.github.io/post/first/</guid>
      <description>

&lt;pre&gt;&lt;code&gt;# 这是 H1 #
## 这是 H2 ##
### 这是 H3 ###
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;这是-h1:e8fb9c67eba912c72729806db31eaa1b&#34;&gt;这是 H1&lt;/h1&gt;

&lt;h2 id=&#34;这是-h2:e8fb9c67eba912c72729806db31eaa1b&#34;&gt;这是 H2&lt;/h2&gt;

&lt;h3 id=&#34;这是-h3:e8fb9c67eba912c72729806db31eaa1b&#34;&gt;这是 H3&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;     区块(前有5个空格)
&amp;gt;     区块(前有5个空格)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;区块(前有5个空格)
区块(前有5个空格)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个一个很长的块注释这个一个很长的块注释这个一个很长的块注释这个一个很长的块注释这个一个很长的块注释这个一个很长的块注释这个一个很长的块注释这个一个很长的块注释这个一个很长的块注释这个一个很长的块注释这个一个很长的块注释&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;*斜体*
**粗体**
***粗斜体***
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;粗体&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;粗斜体&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- 无序列表项a
- 无序列表项b
- 无序列表项c
- 无序列表项d
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;无序列表项a&lt;/li&gt;
&lt;li&gt;无序列表项b&lt;/li&gt;
&lt;li&gt;无序列表项c&lt;/li&gt;
&lt;li&gt;无序列表项d&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;1. 数字序号1
2. 数字序号2
3. 数字序号3
4. 数字序号4
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;数字序号1&lt;/li&gt;
&lt;li&gt;数字序号2&lt;/li&gt;
&lt;li&gt;数字序号3&lt;/li&gt;
&lt;li&gt;数字序号4&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;自动link:  &amp;lt;http://example.com/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自动link:  &lt;a href=&#34;http://example.com/&#34;&gt;http://example.com/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[markdown的官方语法说明](http://daringfireball.net/projects/markdown/syntax)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://daringfireball.net/projects/markdown/syntax&#34;&gt;markdown的官方语法说明&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;引用例子: 访问了3个网站 [Google][1] 和 [Yahoo][2] 和 [MSN][3]



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引用例子: 访问了3个网站 &lt;a href=&#34;http://google.com/&#34; title=&#34;Google&#34;&gt;Google&lt;/a&gt; 和 &lt;a href=&#34;http://search.yahoo.com/&#34; title=&#34;Yahoo Search&#34;&gt;Yahoo&lt;/a&gt; 和 &lt;a href=&#34;http://search.msn.com/&#34; title=&#34;MSN Search&#34;&gt;MSN&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;图片：![alt 图片的alt](http://imgcache.qq.com/bossweb/service/v4/images/logo_x5.png &amp;quot;图片的Title&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图片：&lt;img src=&#34;http://imgcache.qq.com/bossweb/service/v4/images/logo_x5.png&#34; alt=&#34;alt 图片的alt&#34; title=&#34;图片的Title&#34; /&gt;
&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;横线
--------------------------
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;横线:&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type InputCode struct {
	InputCode string
	GenAction string
}
func IsLocalHost(host string) bool {
	return strings.HasPrefix(host, &amp;quot;localhost&amp;quot;) || strings.HasPrefix(host, &amp;quot;127.0.0.1&amp;quot;) || strings.HasPrefix(host, &amp;quot;192.168.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type InputCode struct {
	InputCode string
	GenAction string
}
func IsLocalHost(host string) bool {
	return strings.HasPrefix(host, &amp;quot;localhost&amp;quot;) || strings.HasPrefix(host, &amp;quot;127.0.0.1&amp;quot;) || strings.HasPrefix(host, &amp;quot;192.168.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>